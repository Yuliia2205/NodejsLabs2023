# NodejsLabs2023
## The tasks for the second lab:
### WEB-Scrapper
В даній роботі необхідно реалізувати найпростіший web-scrapper. Необхідно обрати веб-сайт з новинами будь-якої тематики. Додаток має мати наступний функціонал:
- Раз в хвилину відправляти запит на головну сторінку та отримувати відповідь.
- Обробити отриману HTML відповідь, а саме отримати список новин.
- Отримані новини зберегти в директорії. Кожна новина в окремому файлі.
- Реалізувати найпростіший веб-сервер (бібліотека net), який віддає список файлів у директорії.

## Відповіді на контрольні питання:
### 1. В чому різниця між setTimeout та setInterval?
Обидва методи setTimeout і setInterval є вбудованими функціями JavaScript для виконання коду після певної затримки. Однак, головна різниця між ними полягає в тому, як вони поводяться при виконанні коду з певною періодичністю.  
Метод setTimeout виконує функцію один раз через певний інтервал часу, вказаний в мілісекундах. Після виконання функції таймер зупиняється.  
Наприклад, наступний код виконає функцію myFunction через 1 секунду:
```
setTimeout(myFunction, 1000);
```
Метод setInterval, з іншого боку, виконує функцію через певний інтервал часу, але повторює цей виклик знову і знову, кожен раз через вказаний інтервал часу. Цикл повторюється, поки не буде викликаний метод clearInterval або поки не буде закрита вкладка браузера.  
Наприклад, наступний код виконує функцію myFunction кожну секунду:
```
setInterval(myFunction, 1000);
```
Важливо пам'ятати, що використання setInterval може призвести до проблем з продуктивністю, якщо функція, яка викликається, потребує багато ресурсів. Тому рекомендується використовувати його обережно і враховувати особливості свого додатка.
### 2. Що таке блокуючий код?
Блокуючий код (blocking code) - це код, який заблоковує виконання програми до того моменту, поки не буде завершена певна операція. Це означає, що програма не зможе виконувати інші завдання, поки блокуюча операція не буде завершена.  
Прикладом блокуючого коду є довгі цикли, операції з введенням/виведенням даних, запити до бази даних або мережі, що можуть затримати виконання програми на деякий час.  
Коли блокуючий код виконується, програма не відповідає на інші події, такі як кліки користувача, події мережі, таймери, що може привести до затримок у роботі програми та негативно вплинути на її продуктивність.  
У JavaScript блокуючий код може бути особливо проблематичним через те, що мова виконується в одному потоці, тобто усі операції виконуються послідовно. Це означає, що якщо блокуючий код займає деякий час, весь інший код буде зупинений до того моменту, поки цей код не буде завершено. Це може призвести до затримок у роботі програми та до несправностей, особливо в додатках з великою кількістю користувачів.  
Щоб уникнути блокування коду, можна використовувати асинхронний код, такий як функції зворотного виклику (callback functions), проміси (promises) або асинхронні функції (async/await), які дозволяють виконувати операції без блокування інших частин програми.  
Один з прикладів блокуючого коду в Node.js може бути зчитування великого файлу. Якщо використовувати синхронний метод зчитування, виконання програми буде заблоковано до того моменту, поки весь файл не буде зчитаний і збережений в пам'яті.  
Наприклад, розглянемо наступний код:
```
const fs = require('fs');

const data = fs.readFileSync('largeFile.txt', 'utf8');
console.log(data);
```
У цьому коді readFileSync є синхронною операцією зчитування файлу. Якщо файл largeFile.txt є дуже великим, зчитування може зайняти багато часу, під час якого програма буде заблокована і не зможе відповідати на інші запити.  
Щоб уникнути блокування, можна використовувати асинхронну операцію readFile:
```
const fs = require('fs');

fs.readFile('largeFile.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log(data);
});
```
У цьому випадку, зчитування файлу відбувається асинхронно, тобто програма не заблокована під час зчитування і може продовжувати виконувати інші завдання. Коли зчитування завершиться, виконається функція зворотного виклику (callback), яка обробить результати зчитування файлу.
### 3. Які переваги асинхронного читання з диску перед синхронним?
Асинхронне читання з диску має кілька переваг порівняно зі синхронним читанням:
- Не блокує виконання програми: під час асинхронного читання програма може продовжувати виконувати інші завдання, не чекаючи, доки дані будуть зчитані з диску. Це особливо корисно для веб-додатків, які мають велику кількість запитів.
- Підтримується більшістю фреймворків та бібліотек: багато фреймворків та бібліотек для Node.js базуються на асинхронному програмуванні, тому асинхронне читання з диску може бути легше і природніше для розробки додатків.
- Підтримує більшу кількість запитів: коли користувач звертається до сервера з запитом, асинхронне читання дозволяє обробляти більшу кількість запитів одночасно, оскільки виконання не заблоковано на дисковій операції.
- Уникнення падіння додатка: під час синхронного читання, якщо зчитуваний файл є дуже великим, це може призвести до падіння додатка через нестачу пам'яті. Асинхронне читання дозволяє уникнути цього, оскільки читання відбувається порціями, що зменшує використання пам'яті.
- Покращення продуктивності: оскільки асинхронне читання з диску не блокує виконання програми, це може покращити продуктивність програми і зменшити час відповіді на запити.
### 4. Опишіть різницю між Callbacks API, Promase API та async/await.
Callbacks API, Promises API та async/await - це три способи роботи з асинхронним кодом в JavaScript.  
Callbacks API - це старіший спосіб роботи з асинхронним кодом. За допомогою Callbacks API, коли асинхронний код виконується, йому передається функція зворотнього виклику, яка буде виконана, коли асинхронна операція завершиться. Callbacks API може бути складним для відлагодження та керування під час зміни потоку виконання.  
Promises API - це більш сучасний та зручний спосіб роботи з асинхронним кодом. Використання Promises дозволяє зберігати стан (виконано чи ні) асинхронної операції та отримувати результат операції, коли вона завершиться. Promises API робить код більш читабельним та менш складним для відлагодження та управління потоками виконання.  
async/await - це ще більш сучасний спосіб роботи з асинхронним кодом, який базується на Promises API. async/await дозволяє писати асинхронний код так, ніби він синхронний, що робить його набагато читабельнішим та менш помилковим. За допомогою async/await, асинхронні функції можуть бути викликані так само, як і синхронні функції, та повертати значення за допомогою оператора "return".  
Отже, Promises API та async/await є більш сучасними та зручними способами роботи з асинхронним кодом в JavaScript, порівняно з Callbacks API, який може бути складним для відлагодження та управління потоками виконання.
### 5. Як обробляються помилки при використанні Promise API?
При використанні Promise API помилки можуть бути оброблені за допомогою методу .catch() або використовуючи блок try/catch.  
Метод .catch():  
Метод .catch() може бути приєднаний до обіцянки (Promise), щоб обробити будь-які помилки, які виникнуть під час виконання обіцянки. Використання .catch() дозволяє уникнути використання блоків try/catch, що дозволяє зробити код більш зрозумілим та менш обтяженим.  
Приклад:
```
fetch('https://example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    console.log(data);
  })
  .catch(error => {
    console.error('There was a problem with the fetch operation:', error);
  });
  ```
Блок try/catch:  
Блок try/catch може бути використаний для обробки помилок в обіцянках (Promise), коли потрібно здійснити додаткові дії після обробки помилки, наприклад, для збору додаткової інформації про помилку або для продовження виконання програми.  
Приклад:
```
try {
  const response = await fetch('https://example.com/data');
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  const data = await response.json();
  console.log(data);
} catch (error) {
  console.error('There was a problem with the fetch operation:', error);
}
```
В обох випадках, помилки можуть бути логовані в консоль чи оброблені іншим чином в залежності від потреб користувача.
### 6. Як створити директорію через модуль fs? За що відповідає параметр mode?
Для створення директорії за допомогою модуля fs в Node.js можна використовувати метод fs.mkdir().  
Синтаксис:
```
fs.mkdir(path[, mode], callback)
```
Параметри:  
- path - шлях до директорії, яку потрібно створити.
- mode - ціле число, що представляє режим дозволу доступу до створюваної директорії. Це необов'язковий параметр і за замовчуванням встановлюється значення 0o777 (що дозволяє читати, записувати та виконувати директорію для всіх користувачів).
- callback - функція, яка буде викликана після завершення створення директорії. Функція має один параметр err, який містить об'єкт помилки, якщо створення директорії не вдалося.  
Приклад створення директорії зі стандартним значенням режиму дозволу доступу:
```
const fs = require('fs');

fs.mkdir('./new-directory', (err) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('Directory created successfully');
});
```
Приклад створення директорії з визначенням режиму дозволу доступу:
```
const fs = require('fs');

// Задаємо режим дозволу доступу 0o755
const mode = 0o755;

fs.mkdir('./new-directory', mode, (err) => {
  if (err) {
    console.error(err);
    return;
  }
  console.log('Directory created successfully');
});
```
Параметр mode визначає режим дозволу доступу до створюваної директорії. Він може бути встановлений у вигляді восьмиричного числа або символьного рядка. Режим дозволу доступу визначає, які дії можуть бути виконані з директорією для різних типів користувачів (власник, група та інші користувачі). Наприклад, значення 0o777 означає, що директорія може бути читана, записана та виконувана всіма користувачами, а значення 0o755 дозволяє тільки власнику директорої  та групі користувачів виконувати директорію, а всі інші користувачі можуть тільки читати її. Режим дозволу доступу можна встановити за допомогою восьмиричного числа, яке складається з трьох наборів по трьох бітах. Кожен набір бітів представляє дозволи для власника, групи та інших користувачів відповідно.

Наприклад, значення 0o777 можна розкласти на наступні трійки бітів: 111 111 111. Перша трійка представляє дозволи для власника, друга трійка - для групи, а третя - для інших користувачів. Кожен біт може мати значення 0 (означає відсутність дозволу) або 1 (означає наявність дозволу). У випадку з 0o777 всі користувачі мають дозвіл на читання, запис та виконання директорії.  
Параметр mode може бути також заданий у вигляді символьного рядка. Символи представляють дозволи для власника, групи та інших користувачів. Для представлення дозволів використовуються символи r (читання), w (запис) та x (виконання). Наприклад, рядок "rwxr-xr-x" відповідає режиму дозволу доступу 0o755, що дозволяє власнику читати, записувати та виконувати директорію, а групі та іншим користувачам - читати та виконувати її, але не записувати.  
У випадку, якщо параметр mode не вказаний, за замовчуванням встановлюється режим дозволу доступу 0o777.  
Значення параметра mode може бути змінене після створення директорії за допомогою методу fs.chmod().
